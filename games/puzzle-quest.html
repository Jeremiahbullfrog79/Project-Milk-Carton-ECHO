<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Safety Puzzle Quest</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #game-header {
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 3px solid #FFD700;
        }

        #game-title {
            font-size: 2.2rem;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 2px 2px 4px #000;
        }

        #game-stats {
            display: flex;
            gap: 25px;
            font-size: 1.1rem;
        }

        #canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            padding: 20px;
        }

        #gameCanvas {
            border: 5px solid #FFD700;
            background: white;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            border-radius: 10px;
        }

        .puzzle-type {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #333;
            padding: 15px 40px;
            border-radius: 15px;
            font-size: 1.5rem;
            font-weight: bold;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            border: 3px solid #FF8C00;
        }

        .level-complete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, #4CAF50, #8BC34A);
            color: white;
            padding: 50px 80px;
            border-radius: 25px;
            font-size: 2.5rem;
            font-weight: bold;
            box-shadow: 0 10px 50px rgba(76, 175, 80, 0.8);
            animation: popIn 0.5s forwards;
            z-index: 1000;
            text-align: center;
            border: 5px solid white;
        }

        @keyframes popIn {
            to { transform: translate(-50%, -50%) scale(1); }
        }

        #hint-btn {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 15px 30px;
            background: linear-gradient(135deg, #4CAF50, #8BC34A);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            border: 3px solid white;
        }

        #hint-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 20px rgba(76, 175, 80, 0.5);
        }

        #skip-btn {
            position: absolute;
            bottom: 20px;
            left: 180px;
            padding: 15px 30px;
            background: linear-gradient(135deg, #FF9800, #FFC107);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            cursor: pointer;
            font-weight: bold;
            border: 3px solid white;
        }

        #exit-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 12px 25px;
            background: linear-gradient(135deg, #f44336, #e91e63);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            border: 3px solid white;
        }

        .combo-display {
            position: absolute;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: #FFD700;
            padding: 20px;
            border-radius: 15px;
            border: 3px solid #FFD700;
            min-width: 150px;
        }

        .combo-display h3 {
            margin-bottom: 10px;
            font-size: 1.3rem;
        }

        .combo-number {
            font-size: 3rem;
            text-align: center;
            color: #FF4500;
            text-shadow: 0 0 10px #FF4500;
        }

        .particle {
            position: absolute;
            font-size: 2rem;
            pointer-events: none;
            animation: float 1s forwards;
        }

        @keyframes float {
            to {
                transform: translateY(-100px);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="game-header">
            <div id="game-title">üß© Safety Puzzle Quest</div>
            <div id="game-stats">
                <span>‚è±Ô∏è <span id="timer">15:00</span></span>
                <span>üéØ Level: <span id="level">1</span></span>
                <span>‚≠ê Stars: <span id="stars">0</span></span>
                <span>üèÜ Score: <span id="score">0</span></span>
                <span>üî• Streak: <span id="streak">0</span></span>
            </div>
        </div>

        <div id="canvas-container">
            <canvas id="gameCanvas" width="900" height="700"></canvas>
            <div class="puzzle-type" id="puzzle-type">Match the Safety Symbols!</div>
            <div class="combo-display">
                <h3>COMBO</h3>
                <div class="combo-number" id="combo">0</div>
            </div>
            <button id="hint-btn" onclick="useHint()">üí° Hint (3)</button>
            <button id="skip-btn" onclick="skipPuzzle()">‚è≠Ô∏è Skip</button>
            <button id="exit-btn" onclick="exitGame()">Exit</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let gameState = {
            level: 1,
            score: 0,
            stars: 0,
            streak: 0,
            combo: 0,
            hintsLeft: 3,
            timeRemaining: 15 * 60,
            currentPuzzle: null,
            selectedTiles: [],
            isChecking: false,
            matches: 0
        };

        const SAFETY_SYMBOLS = ['üö®', 'üöë', 'üöí', 'üëÆ', 'üîí', 'üíä', '‚òéÔ∏è', 'üè•', 'üõ°Ô∏è', '‚ö†Ô∏è', 'üÜò', 'üö™'];
        const TILE_SIZE = 100;
        let COLS = 4;
        let ROWS = 4;

        function generateMatchingPuzzle() {
            // Increase difficulty with levels
            if (gameState.level >= 3) {
                COLS = 5;
                ROWS = 4;
            }
            if (gameState.level >= 5) {
                COLS = 6;
                ROWS = 4;
            }
            if (gameState.level >= 7) {
                COLS = 6;
                ROWS = 5;
            }

            const symbols = [];
            const numPairs = (COLS * ROWS) / 2;

            for (let i = 0; i < numPairs; i++) {
                const symbol = SAFETY_SYMBOLS[i % SAFETY_SYMBOLS.length];
                symbols.push(symbol, symbol);
            }

            // Shuffle
            for (let i = symbols.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [symbols[i], symbols[j]] = [symbols[j], symbols[i]];
            }

            const tiles = [];
            const startX = (canvas.width - (COLS * (TILE_SIZE + 10))) / 2;
            const startY = (canvas.height - (ROWS * (TILE_SIZE + 10))) / 2;

            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    tiles.push({
                        x: startX + x * (TILE_SIZE + 10),
                        y: startY + y * (TILE_SIZE + 10),
                        gridX: x,
                        gridY: y,
                        symbol: symbols[y * COLS + x],
                        matched: false,
                        flipped: false,
                        pulse: 0
                    });
                }
            }

            gameState.matches = 0;
            return { tiles, type: 'matching', totalPairs: numPairs };
        }

        function drawPuzzle() {
            // Clear with gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#f0f0f0');
            gradient.addColorStop(1, '#e0e0e0');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (!gameState.currentPuzzle) return;

            gameState.currentPuzzle.tiles.forEach((tile, index) => {
                tile.pulse += 0.05;

                // Draw tile shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(tile.x + 5, tile.y + 5, TILE_SIZE, TILE_SIZE);

                // Draw tile
                if (tile.matched) {
                    ctx.fillStyle = '#4CAF50';
                    const scale = 1 + Math.sin(tile.pulse) * 0.05;
                    const offset = (TILE_SIZE * (1 - scale)) / 2;
                    ctx.save();
                    ctx.translate(tile.x + offset, tile.y + offset);
                    ctx.scale(scale, scale);
                    ctx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
                    ctx.restore();
                } else if (tile.flipped) {
                    ctx.fillStyle = '#2196F3';
                    ctx.fillRect(tile.x, tile.y, TILE_SIZE, TILE_SIZE);
                } else {
                    // Gradient for unflipped tiles
                    const tileGradient = ctx.createLinearGradient(tile.x, tile.y, tile.x + TILE_SIZE, tile.y + TILE_SIZE);
                    tileGradient.addColorStop(0, '#FFD700');
                    tileGradient.addColorStop(1, '#FFA500');
                    ctx.fillStyle = tileGradient;
                    ctx.fillRect(tile.x, tile.y, TILE_SIZE, TILE_SIZE);
                }

                // Border
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 4;
                ctx.strokeRect(tile.x, tile.y, TILE_SIZE, TILE_SIZE);

                // Highlight effect
                if (!tile.matched) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(tile.x + 3, tile.y + 3, TILE_SIZE - 6, TILE_SIZE - 6);
                }

                // Draw symbol or back
                ctx.font = 'bold 60px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                if (tile.flipped || tile.matched) {
                    ctx.fillStyle = '#fff';
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = '#000';
                    ctx.fillText(tile.symbol, tile.x + TILE_SIZE/2, tile.y + TILE_SIZE/2);
                    ctx.shadowBlur = 0;
                } else {
                    ctx.fillStyle = '#333';
                    ctx.font = 'bold 50px Arial';
                    ctx.fillText('?', tile.x + TILE_SIZE/2, tile.y + TILE_SIZE/2);
                }
            });
        }

        canvas.addEventListener('click', (e) => {
            if (!gameState.currentPuzzle || gameState.isChecking) return;

            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            gameState.currentPuzzle.tiles.forEach((tile, index) => {
                if (clickX >= tile.x && clickX <= tile.x + TILE_SIZE &&
                    clickY >= tile.y && clickY <= tile.y + TILE_SIZE &&
                    !tile.matched && !tile.flipped &&
                    gameState.selectedTiles.length < 2) {

                    tile.flipped = true;
                    gameState.selectedTiles.push(index);

                    // Sound effect simulation
                    createParticle('‚ú®', tile.x + TILE_SIZE/2, tile.y + TILE_SIZE/2);

                    if (gameState.selectedTiles.length === 2) {
                        gameState.isChecking = true;
                        setTimeout(checkMatch, 800);
                    }

                    drawPuzzle();
                }
            });
        });

        function checkMatch() {
            const [idx1, idx2] = gameState.selectedTiles;
            const tile1 = gameState.currentPuzzle.tiles[idx1];
            const tile2 = gameState.currentPuzzle.tiles[idx2];

            if (tile1.symbol === tile2.symbol) {
                // MATCH!
                tile1.matched = true;
                tile2.matched = true;
                gameState.score += 100 * (gameState.combo + 1);
                gameState.stars++;
                gameState.combo++;
                gameState.streak++;
                gameState.matches++;

                // Particles!
                createParticle('üí•', tile1.x + TILE_SIZE/2, tile1.y + TILE_SIZE/2);
                createParticle('üí•', tile2.x + TILE_SIZE/2, tile2.y + TILE_SIZE/2);
                createParticle('‚≠ê', canvas.width/2, canvas.height/2);

                // Check if all matched
                if (gameState.matches >= gameState.currentPuzzle.totalPairs) {
                    setTimeout(() => puzzleComplete(), 500);
                }
            } else {
                // NO MATCH - FIX: Reset flipped state
                gameState.combo = 0;
                setTimeout(() => {
                    tile1.flipped = false;
                    tile2.flipped = false;
                    drawPuzzle();
                }, 100);
            }

            gameState.selectedTiles = [];
            gameState.isChecking = false;
            updateStats();
            drawPuzzle();
        }

        function puzzleComplete() {
            const bonus = gameState.level * 100;
            const streakBonus = gameState.streak * 50;
            gameState.score += bonus + streakBonus;

            showLevelComplete(`üéâ LEVEL ${gameState.level} COMPLETE!\n\n‚≠ê Stars: ${gameState.stars}\nüî• Streak: ${gameState.streak}\nüèÜ Bonus: +${bonus + streakBonus}\n\nGET READY FOR NEXT LEVEL!`);

            setTimeout(() => {
                gameState.level++;
                gameState.combo = 0;
                gameState.selectedTiles = [];
                gameState.currentPuzzle = generateMatchingPuzzle();
                updateStats();
                drawPuzzle();
            }, 3000);
        }

        function showLevelComplete(text) {
            const complete = document.createElement('div');
            complete.className = 'level-complete';
            complete.style.whiteSpace = 'pre-line';
            complete.textContent = text;
            document.body.appendChild(complete);

            setTimeout(() => {
                complete.style.opacity = '0';
                complete.style.transform = 'translate(-50%, -50%) scale(0)';
                setTimeout(() => complete.remove(), 500);
            }, 2500);
        }

        function createParticle(emoji, x, y) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.textContent = emoji;
            particle.style.left = x + 'px';
            particle.style.top = y + 'px';
            document.body.appendChild(particle);

            setTimeout(() => particle.remove(), 1000);
        }

        function useHint() {
            if (gameState.hintsLeft <= 0) {
                showNotification('‚ùå No hints left!');
                return;
            }

            if (gameState.selectedTiles.length > 0) {
                showNotification('‚ö†Ô∏è Finish current selection first!');
                return;
            }

            gameState.hintsLeft--;
            document.getElementById('hint-btn').textContent = `üí° Hint (${gameState.hintsLeft})`;

            // Find two matching unmatched tiles
            const unmatched = gameState.currentPuzzle.tiles.filter(t => !t.matched && !t.flipped);
            const symbols = {};

            for (let tile of unmatched) {
                if (!symbols[tile.symbol]) {
                    symbols[tile.symbol] = [];
                }
                symbols[tile.symbol].push(tile);
            }

            // Find a matching pair
            for (let symbol in symbols) {
                if (symbols[symbol].length >= 2) {
                    symbols[symbol][0].flipped = true;
                    symbols[symbol][1].flipped = true;
                    drawPuzzle();

                    setTimeout(() => {
                        symbols[symbol][0].flipped = false;
                        symbols[symbol][1].flipped = false;
                        drawPuzzle();
                    }, 2000);
                    break;
                }
            }
        }

        function skipPuzzle() {
            if (confirm('Skip this level? (No points awarded)')) {
                gameState.level++;
                gameState.combo = 0;
                gameState.streak = Math.max(0, gameState.streak - 5);
                gameState.selectedTiles = [];
                gameState.currentPuzzle = generateMatchingPuzzle();
                updateStats();
                drawPuzzle();
            }
        }

        function updateStats() {
            document.getElementById('level').textContent = gameState.level;
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('stars').textContent = gameState.stars;
            document.getElementById('combo').textContent = gameState.combo;
            document.getElementById('streak').textContent = gameState.streak;
        }

        function showNotification(text) {
            const notif = document.createElement('div');
            notif.style.cssText = `
                position: absolute;
                top: 150px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(244, 67, 54, 0.95);
                color: white;
                padding: 15px 30px;
                border-radius: 10px;
                font-size: 1.2rem;
                font-weight: bold;
                z-index: 999;
                border: 3px solid white;
            `;
            notif.textContent = text;
            document.body.appendChild(notif);

            setTimeout(() => {
                notif.style.opacity = '0';
                setTimeout(() => notif.remove(), 300);
            }, 1500);
        }

        function exitGame() {
            if (confirm(`Exit Puzzle Quest?\n\nLevel: ${gameState.level}\nScore: ${gameState.score}\nStars: ${gameState.stars}\n\nPlay again by completing another scenario!`)) {
                window.location.href = 'game-launcher.html?age=11-13';
            }
        }

        // Timer
        function startTimer() {
            setInterval(() => {
                gameState.timeRemaining--;
                const minutes = Math.floor(gameState.timeRemaining / 60);
                const seconds = gameState.timeRemaining % 60;
                document.getElementById('timer').textContent =
                    `${minutes}:${seconds.toString().padStart(2, '0')}`;

                if (gameState.timeRemaining <= 0) {
                    alert(`Time's up! Final Score: ${gameState.score}\n\nComplete another ECHO scenario to play more!`);
                    exitGame();
                }
            }, 1000);
        }

        // Animation loop
        function animate() {
            drawPuzzle();
            requestAnimationFrame(animate);
        }

        // Initialize
        gameState.currentPuzzle = generateMatchingPuzzle();
        startTimer();
        animate();
        showNotification('üß© Match the safety symbols! Build your combo!');
    </script>
</body>
</html>
